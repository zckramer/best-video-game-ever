# fps_survival Project Context & Guidelines

## Project Overview
- **Engine**: Unreal Engine 5.7
- **Project Type**: FPS Survival Game
- **Language**: C++ (with Blueprints for non-critical features only)
- **Target Platform**: Windows (primary)
- **Development Methodology**: **CODE-FIRST APPROACH**

## Development Methodology: CODE-FIRST

### Core Principle
**All gameplay logic, systems, and features are implemented in C++ first.** Blueprints are used only for:
- Visual iteration and tuning
- Non-critical UI elements
- Content-specific customization that doesn't impact core systems
- Rapid prototyping of non-performance-critical features
- **Explicit prototyping when exploring new mechanics** (with plan to refactor to C++)

### Quick Reference: When to Use What

| Scenario | Use | Why |
|----------|-----|-----|
| Core gameplay system | **C++** | Performance, version control, maintainability |
| Tuning values/balance | Blueprint on C++ class | Easy iteration, designer-friendly |
| Rapid mechanic exploration | **Blueprint (prototype)** | Fast feedback, iterate feel quickly |
| Validated prototype moving to production | **Refactor to C++** | Lock down design, optimize, integrate |
| Performance-critical code | **C++** | Only option |
| UI customization | Blueprint | Safe, non-critical |
| Visual effects/animations | Blueprint | Perfect use case |

### Why Code-First?
1. **Performance** - C++ compiled code is faster than Blueprint VM
2. **Maintainability** - Code is easier to review, test, and refactor
3. **Version Control** - C++ source is text-based; Blueprints are binary blobs
4. **Collaboration** - Code conflicts are resolvable; Blueprint conflicts are nightmares
5. **Documentation** - Code can be self-documenting with proper comments
6. **Professional Standards** - Aligns with AAA studio practices

### What This Means for Development

**DO:**
- ✅ Implement core gameplay systems in C++
- ✅ Create base classes in C++ that Blueprints can extend
- ✅ Use C++ for all performance-critical code
- ✅ Write AI logic, input handling, and game mechanics in C++
- ✅ Create Blueprint children of C++ classes for customization

**DON'T:**
- ❌ Implement core logic in Blueprints
- ❌ Create Blueprint-only gameplay systems
- ❌ Use Blueprints for frequently-updated logic
- ❌ Put critical game mechanics only in Blueprints
- ❌ Commit Blueprint files (.uasset) to Git

### Example: Adding a New Weapon System

❌ **Wrong (Blueprint-First):**
```
Create BP_Weapon Blueprint
  → Implement all firing logic in Blueprint
  → Store ammo count in Blueprint variables
  → Handle damage calculations in Blueprint
```

✅ **Correct (Code-First):**
```
C++: Create AWeapon class with firing logic
C++: Implement damage calculations
C++: Handle ammo management
Blueprint: Create BP_AssaultRifle extending AWeapon
Blueprint: Set firing rate, damage values, visual effects
```

## Code Organization

### Directory Structure
```
Source/
├── fps_survival/
│   ├── Public/          # Public headers (UCLASS declarations)
│   ├── Private/         # Implementation (.cpp files)
│   └── fps_survival.Build.cs
```

### File Organization Rules
- **Public headers (`.h`)**: Place here if the class is marked with `UCLASS()`, `USTRUCT()`, or `UENUM()`
  - These need to be public for Unreal's reflection system to process them
  - Must have the **`FPS_SURVIVAL_API`** macro for module API export
  - Examples: `AMyPlayerController`, game-facing interfaces, data structures
  
- **Private implementation (`.cpp`)**: Place in `Private/` folder
  - Function implementations
  - Static/internal helper functions
  
- **Private headers (`.h`)**: Only in `Private/` if:
  - The header is **NOT** marked with `UCLASS()`, `USTRUCT()`, etc.
  - It's only used internally within a single `.cpp` file
  - Examples: internal helper structs, pimpl patterns

### Naming Conventions
- **Classes**: Use `A` prefix for Actors, `U` prefix for UObjects, `F` for structs (Unreal Engine standard)
- **Functions**: PascalCase, descriptive names (e.g., `GetPlayerHealth()`, `OnPlayerDeath()`)
- **Variables**: 
  - Public: PascalCase with no prefix (e.g., `PlayerSpeed`)
  - Private: camelCase with `_` prefix (e.g., `_playerHealth`, `_weaponAmmo`)
- **Constants**: ALL_CAPS with `MAX_`, `MIN_`, `DEFAULT_` prefixes where appropriate
- **Booleans**: Use `Is`, `Has`, `Can` prefixes (e.g., `bIsAlive`, `bHasWeapon`, `bCanShoot`)

## Code Style Guidelines

### C++ Standards
- Target: C++17 or compatible with UE5.7 defaults
- Use Unreal Engine macros: `UPROPERTY()`, `UFUNCTION()`, `UPARAM()` for exposed blueprint functionality
- Always use forward declarations in headers when possible
- Keep `.h` files clean; implementation details go in `.cpp`

### Required Module API Macro
**All public classes must include the module API macro:**
```cpp
UCLASS()
class FPS_SURVIVAL_API AMyPlayerController : public APlayerController
{
    GENERATED_BODY()
};
```
**Why?** Without `FPS_SURVIVAL_API`, the Unreal Engine's reflection system may not properly export/recognize your class, especially when:
- Building with different configurations (Debug/Shipping)
- Using the class in Blueprints
- Linking against your module from other modules
- Generating .generated.h files with Unreal Header Tool (UHT)

### Header Comments
Include GENERATED_BODY() macros for reflection system:
```cpp
UCLASS()
class FPS_SURVIVAL_API AMyPlayerController : public APlayerController
{
    GENERATED_BODY()
    
public:
    // ...
};
```

### Function Documentation
Use Unreal-style comments for public functions:
```cpp
/** 
 * Brief description of what this function does.
 * @param Param1 Description of first parameter
 * @return Description of return value
 */
void MyFunction(float Param1);
```

## Gameplay Systems

### Player Controller
- Location: `Source/fps_survival/Private/MyPlayerController.h|cpp`
- Responsibilities: Input handling, player state management, camera control
- Should NOT contain shooting/combat logic (delegate to weapons/inventory)

### Character/Pawn
- Should handle movement and basic gameplay
- Combat logic should be separated into weapon/inventory systems

### Game Mode
- Should manage game state (spawning, scoring, rounds)
- Should NOT contain player-specific logic

## Best Practices

### Memory Management
- Use smart pointers: `TUniquePtr<>`, `TSharedPtr<>` for C++ objects
- Use `UPROPERTY()` with proper garbage collection markers for UObjects
- Prefer stack allocation when possible

### Blueprint Integration
- Mark functions/properties with `UFUNCTION(BlueprintCallable)`, `UPROPERTY(EditAnywhere)` as needed
- Use `UPROPERTY(VisibleAnywhere)` for read-only blueprint exposure
- Keep gameplay logic in C++, delegate to Blueprints only for customization

### Logging
Use Unreal's logging system:
```cpp
UE_LOG(LogYourCategory, Warning, TEXT("Message: %s"), *SomeString);
```

### Input Handling
- Use Enhanced Input System (UE5 standard) if available
- Separate input mapping from gameplay logic
- Input callbacks should be lightweight, delegate heavy work to other systems

## Asset Naming

### Blueprints & Classes
- `BP_ActorName` for Blueprint classes
- `C_ActorName` for C++ classes visible in content browser

### Materials & Textures
- `M_MaterialName` for materials
- `T_TextureName_[Diffuse|Normal|Roughness|Metallic]` for textures

### Animations & Sounds
- `Anim_ActionName` for animation sequences
- `S_SoundName` for sound files

## Version Control Considerations
- DO NOT commit generated files (Intermediate/, Binaries/, Saved/)
- DO commit: Source/, Content/, .uproject, project configuration files
- Use .gitignore appropriate for Unreal Engine projects

### Git Workflow & Conventions
- **Branch naming**: `feature/name`, `bugfix/name`, `docs/name`, `refactor/name`
- **Commit messages**: Use [Conventional Commits](https://www.conventionalcommits.org/) format
  - Examples: `feat(player): add sprint ability`, `fix(weapon): correct reload timing`
- **Pull requests**: Require code review before merging to main/master
- **Line endings**: Use LF (Unix-style) for all text files via `.gitattributes`
- **Binary handling**: UE5 assets (.uasset, .umap) use merge=union for conflict resolution

### Large File Storage (Optional)
For very large assets, consider Git LFS (Git Large File Storage):
```bash
git lfs install
git lfs track "*.uasset"
git add .gitattributes
```

## Testing & Debugging
- Use Unreal's built-in tools: Output Log, Stat commands
- Add debug drawing when working on gameplay systems:
  ```cpp
  if (bDebugDraw)
  {
      DrawDebugLine(World, Start, End, FColor::Green, false, 1.0f);
  }
  ```

## When Working with This Codebase
1. Check existing patterns before introducing new ones
2. Keep gameplay systems modular and loosely coupled
3. Expose only necessary properties/functions to Blueprint
4. Use const-correctness throughout
5. Prefer composition over inheritance
6. Add comments for WHY code exists, not WHAT it does (code is self-documenting)

## ⚠️ IMPORTANT: CODE-FIRST METHODOLOGY

**For AI Assistants / Agent Instances:**

When you receive requests to implement features or systems in this project, **ALWAYS**:

1. **Ask or assume C++ implementation first** - Unless explicitly told otherwise, implement in C++
2. **Do NOT suggest Blueprint-only solutions** - Even if it seems faster/easier (unless explicitly prototyping)
3. **Create C++ base classes** - Let designers extend in Blueprint if needed
4. **Review this section if uncertain** - Refer back to "Development Methodology: CODE-FIRST" above
5. **Commit only C++ code to Git** - Never commit .uasset/.umap files
6. **Follow the directory structure** - Public headers in Public/, implementations in Private/

**When the user says "prototype this" or "just get it working":**
- Switch to "just get the shit done" mentality
- Use Blueprints liberally for rapid exploration
- Document that it's prototype code
- Plan to refactor to C++ when approach is validated
- Don't worry about perfect architecture during prototyping

**Example Prompts to Expect:**
- "Add a sprint ability to the player" → Implement `SetSprintActive()`, `GetSprintSpeed()` in C++
- "Quick prototype: what if we had grappling hooks?" → Use Blueprints, iterate fast, nail the feel
- "Create an inventory system" → Build `UInventoryComponent` in C++, let Blueprint handle UI
- "Just hack together a boss fight real quick" → Blueprint is fine, iterate on the mechanic first

**Red Flags (Don't Do These):**
- ❌ "Let's just make this in Blueprint" (without C++ base first) *unless prototyping*
- ❌ "We'll implement the logic in Blueprint later" (we won't)
- ❌ "This is too complex for C++, use Blueprint" (it's not, and use C++ for production)
- ❌ Suggesting to commit .uasset files or Content/ folder to Git

## Common Configuration Issues to Avoid

### "Mutant" Classes (UHT Reflection System Rejections)
Unreal Engine's reflection system will reject or misinterpret classes that violate these rules:

1. **Missing API Macro** - Class missing `FPS_SURVIVAL_API` or `EXPORT` keyword
   - Result: Class not properly exported from module, reflection system confused
   - Fix: Always add `class FPS_SURVIVAL_API AMyClass`

2. **File in Wrong Folder** - UCLASS/USTRUCT/UENUM in Private folder
   - Result: UHT can't find headers, reflection fails, Blueprint access broken
   - Fix: Move to `Public/` folder

3. **Missing Includes** - Not including `#include "MyClass.generated.h"`
   - Result: GENERATED_BODY() macro fails, reflection broken
   - Fix: Always end your header with `#include "YourFileName.generated.h"`

4. **Incorrect Class Declaration Order** - Putting UCLASS() after class inheritance
   - Result: UHT parser errors
   - Fix: Always put `UCLASS()` on the line BEFORE `class ClassName`

5. **Missing GENERATED_BODY()** - Any UCLASS without GENERATED_BODY()
   - Result: Reflection system incomplete, crashes at runtime
   - Fix: Always include `GENERATED_BODY()` as first line in class body

6. **Circular Dependencies** - Headers including each other in a circle
   - Result: Compilation failures, UHT errors
   - Fix: Use forward declarations `class AMyClass;` in headers, include only in `.cpp`

7. **Using Private Variables in UPROPERTY** - Marking private members with UPROPERTY()
   - Result: UHT warnings/errors, potential reflection issues
   - Fix: Make exposed properties public or use UPROPERTY on public members only

---

**Last Updated**: [Date when you last reviewed this]
**Maintained By**: [Your name/team]
